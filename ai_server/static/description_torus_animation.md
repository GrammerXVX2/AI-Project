# Метаданные документа

* Имя файла: torus_animation.rs
* Язык программирования: Rust
* Основные зависимости: crossterm, std::sync, std::thread, std::time
* Тип приложения: CLI (Command Line Interface), TUI (Terminal User Interface), 3D Render, ASCII Art

## Краткое содержание (Summary)

* Код реализует рендеринг вращающегося 3D-тора (пончика) в консоли с использованием ASCII-символов. Приложение использует многопоточность для разделения логики отрисовки и обработки пользовательского ввода. Визуализация основана на математической проекции 3D-координат на 2D-плоскость терминала с использованием Z-буфера (буфера глубины) для корректного отображения перекрывающихся поверхностей.

## Детальное техническое описание

### Математическая модель и Рендеринг (draw_torus)

* Алгоритм: Реализация классического алгоритма "пончика" (аналогичного известному коду Энди Слоана), использующего параметрические уравнения тора.
* Пространство: Используются два угла вращения (theta — основное кольцо, phi — сечение трубы) и два угла анимации (A и B — вращение всей фигуры вокруг осей X и Z).
* Проекция: Вычисляется ooz (one over z) для определения глубины. Координаты проецируются на 2D-экран с учетом перспективы.
* Z-буфер: Используется массив zbuffer размером width *height для хранения обратной глубины каждой точки. Символ рисуется только если точка находится ближе к камере, чем предыдущая.
* Освещение (Luminance): Рассчитывается скалярное произведение нормали поверхности и вектора света. Результат (от 0 до 1) мапится на строку символов .,-~:;=!*#$@ (от темного к светлому).

### Исправления и Оптимизации (Specific Implementation Details)

Код содержит ряд специфических исправлений для улучшения визуального качества в современных терминалах:

* Динамический размер: Функция draw_torus принимает width и height как аргументы, адаптируясь под изменение размера окна.
* Клиппинг (Clipping): Константа расстояния до объекта K2 увеличена с 5.0 до 15.0, чтобы предотвратить обрезание фигуры при вращении вблизи "камеры".
* Коррекция Aspect Ratio: При расчете координаты xp (X на экране) применяется множитель 1.5, чтобы компенсировать прямоугольную форму символов терминала (которые обычно выше, чем шире).
* Расчет масштаба K1 учитывает, что высота символа примерно в 2 раза больше ширины (height * 2.0).
* Устранение мерцания: Вместо полной очистки экрана (ClearType::All), которая вызывает мерцание, используется MoveTo(0, 0) для перезаписи кадра поверх старого (эмуляция двойной буферизации).

### Управление терминалом и Многопоточность

* Библиотека crossterm: Используется для управления "сырым" режимом терминала, скрытия курсора и переключения в альтернативный экран (EnterAlternateScreen).
* Архитектура потоков:
* Main Thread: Занимается инициализацией терминала и бесконечным циклом опроса событий (polling) для отлова нажатия клавиши Esc.
* Render Thread: Отдельный поток (thread::spawn), который выполняет математические вычисления и вывод строк в stdout.
* Синхронизация: Используется Arc<AtomicBool> (переменная running) для безопасной остановки потока рендеринга из главного потока при выходе.
* Тайминг: Используется std::time::Instant для расчета угла вращения на основе реального времени, а не количества кадров. thread::sleep ограничивает частоту кадров (~20 FPS).

## Ключевые слова для поиска (Keywords)

Rust, ASCII torus, 3D rendering in terminal, crossterm events, Z-buffer algorithm, thread synchronization, AtomicBool, terminal aspect ratio correction, 3D projection math, Rust CLI animation.
